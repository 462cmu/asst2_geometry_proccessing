{"name":"Assignment 2: MeshEdit","tagline":"CMU 15-462/662 Assignment 2: A Mini Mesh editor","body":"![Resampled mesh](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/CMU462Assignment2TeaserGeometryProcessing.png)\r\n\r\n### Due Date\r\nMon Oct 5th, 11:59pm\r\n\r\n### Overview \r\nIn this project you will implement a simple mesh editor that allows you to manipulate and resample triangle meshes.  When you are done, you will have a tool that allows you to load and edit basic COLLADA mesh files that are now used by many major modeling packages and real time graphics engines.  (You can create your own COLLADA files in free software like [Blender](http://blender.org).)\r\n\r\n### Getting started\r\nWe will be distributing assignments with git. You can find the repository for this assignment at <http://462cmu.github.io/asst2_meshedit/>. If you are unfamiliar with git, here is what you need to do to get the starter code:\r\n```\r\n$ git clone https://github.com/462cmu/asst2_meshedit.git\r\n```\r\nThis will create a <i class=\"icon-folder\"> </i> *asst2_meshedit* folder with all the source files. \r\n\r\n### Build Instructions\r\nIn order to ease the process of running on different platforms, we will be using [CMake](http://www.cmake.org \"CMake Homepage\") for our assignments. You will need a CMake installation of version 2.8+ to build the code for this assignment. The GHC 5xxx cluster machines have all the packages required to build the project. It should also be relatively easy to build the assignment and work locally on your OSX or Linux. Building on Windows is currently not supported. \r\n\r\nIf you are working on OS X and do not have CMake installed, we recommend installing it through [Macports](https://www.macports.org/):\r\n```\r\nsudo port install cmake\r\n```\r\nOr [Homebrew](http://brew.sh/):\r\n```\r\nbrew install cmake\r\n```\r\n\r\nTo build your code for this assignment:\r\n\r\n- Create a directory to build your code:\r\n```\r\n$ cd asst2_meshedit && mkdir build && cd build\r\n``` \r\n- Run CMake to generate makefile:\r\n```\r\n$ cmake ..\r\n```\r\n- Build your code:\r\n```\r\n$ make\r\n```\r\n- Install the executable (to asst2_meshedit/bin):\r\n```\r\n$ make install\r\n```\r\n\r\n### Using the MeshEdit App\r\n\r\nWhen you have successfully built your code, you will get an executable named **meshedit**. The **meshedit** executable takes exactly one argument from the command line. You may load a single COLLADA file by specifying its path. For example, to load the example file <i class=\"icon-file\"> </i>*dae/quadball.dae* from your build directory:\r\n\r\n```\r\n./meshedit ../dae/quadball.dae\r\n```\r\n\r\nWhen you first run the application, you will see a picture of a mesh made of triangles. The starter code that you must modify is drawing this mesh.  The editor already supports some basic functionality, like moving vertices around in space, which you can do by just clicking and dragging on a vertex.  You can also rotate the camera by right-clicking and dragging (or dragging on the background), and zoom in and out using the scroll wheel or multi-touch scrolling on a trackpad.  Hitting the spacebar will reset the view.  As you move the cursor around the screen, you'll notice that mesh elements (faces, edges, and vertices) under the cursor get highlighted.  Clicking on one of these elements will display some information about the element and its associated data.\r\n\r\n![MeshEdit GUI](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/MeshEditScreenshot.png)\r\n\r\nIn this assignment, you will add additional functionality to the program that allows you to modify the mesh in a variety of ways.  Each of these methods is exposed through the viewer.  There will be two basic types of operations:\r\n\r\n1. (FIRST WEEK) Local resampling - modifies the mesh in a small neighborhood around the currently selected mesh element.\r\n2. (SECOND WEEK) Global resampling - modifes the entire mesh, in an effort to improve the overall quality, size, etc.\r\n\r\nEach operation will be executed with a key press (see table below).\r\n\r\n'f' - flip the currently selected edge\r\n's' - split the currently selected edge\r\n'c' - collapse the currently selected edge\r\n'u' - upsample the mesh\r\n'd' - downsample the mesh\r\n'r' - resample the mesh\r\n\r\nNotice that currently, nothing happens when keys are pressed - this is because you haven't yet implemented resampling!  Unlike the previous assignment, no reference solution is provided.  However, we will provide several examples of correct input/output pairs for each remeshing operation.\r\n\r\nNote that each COLLADA file may contain multiple mesh objects; more generally, a COLLADA file describes a __scene graph__ (much like SVG) that is a hierarchical representation of all objects in the scene (meshes, cameras, lights, etc.), as well as their coordinate transformations.  Global resampling methods will be run on whichever mesh is currently selected.\r\n\r\n### Summary of Viewer Controls\r\nA table of all the keyboard controls in the **meshedit** application is provided below.\r\n\r\n| Command                              | Key                                                |\r\n| ------------------------------------ |:--------------------------------------------------:|\r\n| Flip the selected edge               | <kbd>F</kbd>                                       |\r\n| Split the selected edge              | <kbd>S</kdb>                                       |\r\n| Collapse the selected edge           | <kbd>C</kdb>                                       |\r\n| Upsample the current mesh            | <kbd>U</kdb>                                       |\r\n| Downsample the current mesh          | <kbd>D</kdb>                                       |\r\n| Resample the current mesh            | <kbd>R</kdb>                                       |\r\n| Increase the target edge length      | <kbd>=</kdb>                                       |\r\n| Decrease the target edge length      | <kbd>-</kdb>                                       |\r\n| Toggle information overlay           | <kbd>I</kdb>                                       |\r\n| Reset camera to default position     | <kbd>SPACE</kdb>                                   |\r\n| Edit a vertex position               | (click and drag on vertex)                         |\r\n| Rotate camera                        | (click and drag on background, or right click)     |\r\n\r\n### What You Need to Do\r\n\r\nThe assignment is divided into two major components: local operations (week 1) and global operations (week 2); the latter will build on the former (e.g., local edge collapses will ultimately be used for global downsampling).  As with the previous assignment, this assignment __involves significant implementation effort. Also, be advised that to meet the requirements of later tasks, you should be sure that your local operations handle corner cases; it won't be enough to work only on simple examples!__  In short: you are highly advised to compete the first component in the first week of the assignment, and to carefully consider the **correctness** of your code, since it will be used later for more complicated tasks.\r\n\r\n __NOTE: The second component (global remeshing) depends on concepts that will be discussed in Lectures 7 and 8, so it is not expected that you understand those requirements at the time this assignment is released.__ \r\n\r\n#### Getting Acquainted with the Starter Code \r\nBefore you start, here are some basic information on the structure of the starter code.\r\n\r\nYour work will be constrained to implementing part of the classes `HalfedgeMesh` and `MeshResampler` in <i class=\"icon-file\"> </i> *student_code.cpp*.  Although the halfedge data structure is designed to support general polygon meshes, you can assume that all meshes used in this assignment will be made of __triangles only__.  You can also assume that the input mesh is __manifold, possibly with boundary__, i.e., that each edge is contained in at most two polygons (or one polygon if it is on the boundary), and each vertex is connected to a single \"fan\" of triangles.  Note that the atomic remeshing operations (split, collapse, and flip) are __supposed__ to preserve the manifold property of the mesh---but it is only your own implementation that can provide this guarantee!  In other words, if you make a mistake in one of the local remeshing operations, it can cause trouble for other routines later down the line (probably causing your program to crash!).\r\n\r\n#### The Halfedge Data Structure\r\n\r\nFor simple mesh operations (e.g., loading a mesh from disk and drawing it on screen), one can use a very simple mesh data structure like __polygon soup__, i.e., just a list of vertices together with a list of polygons connecting them.  For many geometry processing tasks, however, this simple representation is no longer sufficient (or leads to unnecessarily bad asymptotic performance).  In this assignment, we use the __halfedge__ data structure, which provides a good tradeoff between simplicity and sophistication.\r\n\r\nThe basic idea behing the halfedge data structure is that, in addition to the usual __vertices__, __edges__, and __faces__ that make up a polygon mesh, we also have an entity called a __halfedge__ that acts like a \"glue\" connecting the different elements.  It is this glue that allows us to easily navigate the mesh.\r\n\r\n![The halfedge data structure](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/halfedgePointers.png)\r\n\r\nIn particular, there are two halfedges associated with each edge (see picture above).  For an edge connecting two vertices i and j, one of its halfedges points from i to j; the other points from j to i.  In other words, we say that the two halfedges are __oppositely oriented__.  One of the halfedges is associated with the face to the \"left\" of the edge; the other is associated with the face to the \"right.\"   Each halfedge knows about the opposite halfedge, which we call its __twin__.  It also knows about the __next__ halfedge around its face, as well as its associated edge, face, and vertex.\r\n\r\nIn contrast, the primitive mesh elements (vertices, edges, and faces) know about only __one__ of their halfedges.  In particular: a vertex knows about one of its \"outgoing\" halfedges; an edge knows about one of its two halfedges; and a face knows about one of the halfedges circulating around its interior.\r\n\r\nIn summary, we have the following relationships:\r\n\r\n| Mesh element                         | Pointers                               |\r\n| ------------------------------------ |:--------------------------------------:|\r\n| Vertex                               | one halfedge                           |\r\n| Edge                                 | one halfedge                           |\r\n| Face                                 | one halfedge                           |\r\n| Halfedge                             | twin, next, vertex, edge, face         |\r\n\r\nThis list emphasizes that it is really the __halfedges__ that connect everything up.  An easy example is if we want to visit all the vertices of a given face.  We can start at the face's halfedge, and follow the \"next\" pointer until we're back at the beginning.  A more interesting example is visiting all the vertices adjacent to a given vertex v.  We can start by getting its outgoing halfedge, then its twin, then its next halfedge; this final halfedge will also point out of vertex v, but it will point __toward__ a different vertex than the first halfedge.  By repeating this process, we can visit all the neighboring vertices:\r\n\r\n![Walking around a vertex](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/vertexTraversal.png)\r\n\r\n(Can you easily do this traversal with a polygon soup?  Why or why not?)  In some sense, a halfedge mesh is kind of like a linked list on steroids.  For instance, the halfedges around a given face (connected by `next` pointers) form a sort of \"cyclic\" linked list, where the tail points back to the head.\r\n\r\nAn interesting consequence of the halfedge representation is that any valid halfedge mesh **must** be manifold and orientable.  In this assignment, we will therefore only provide manifold, oriented meshes as input (in fact, the parser will complain if the input does not satisfy these criteria).\r\n\r\n#### The HalfedgeMesh Class\r\n\r\nFor this assignment, we've already provided a C++ implementation of the halfedge data structure.  Although the detailed implementation might appear a bit initimidating at first (especially if you haven't had much experience with C++), the basic interface you'll need for this assignment is not much different from the abstract description given above.  For instance, suppose we have a face f and want to print out the positions of all its vertices.  We would write a routine like this:\r\n\r\n    void printVertexPositions( FaceCIter f )\r\n    {\r\n       HalfEdgeCIter h = f->halfedge(); // get the first halfedge of the face\r\n       do\r\n       {\r\n          VertexCIter v = h->vertex(); // get the vertex of the current halfedge\r\n\r\n          cout << v->position << endl; // print the vertex position\r\n\r\n          h = h->next(); // move to the next halfedge around the face\r\n       }\r\n       while( h != f->halfedge() ); // keep going until we're back at the beginning\r\n    }\r\n\r\n(For an explanation of the low-level details (e.g., why do we call it a `FaceCIter` rather than just a `Face`?), see the inline documentation in the code, or the corresponding Doxygen documentation.)  Similarly, to print out the positions of all the neighbors of a given vertex we could write a routine like this:\r\n\r\n    void printNeighborPositions( VertexCIter v )\r\n    {\r\n       HalfEdgeCIter h = v->halfedge(); // get one of the outgoing halfedges of the vertex\r\n       do\r\n       {\r\n          VertexCIter v = h->vertex(); // get the vertex of the current halfedge\r\n\r\n          cout << v->position << endl; // print the vertex position\r\n\r\n          h = h->twin()->next(); // move to the next outgoing halfedge of the vertex\r\n       }\r\n       while( h != v->halfedge() ); // keep going until we're back at the beginning\r\n    }\r\n\r\nTo iterate over __all__ the vertices in a halfedge mesh, we could write a loop like this:\r\n\r\n    for( VertexCIter v = mesh.verticesBegin(); v != mesh.verticesEnd(); v++ )\r\n    {\r\n       printNeighborPositions( v ); // do something interesting here\r\n    }\r\n\r\nInternally, the lists of vertices, edges, faces, and halfedges are stored as __linked lists__, which allows us to easily add or delete elements to our mesh.  For instance, to add a new vertex we can write\r\n\r\n    Vertex v = mesh.newVertex();\r\n\r\nLikewise, to delete a vertex we can write\r\n\r\n    mesh.deleteVertex( v );\r\n\r\nNote, however, that one should be **very, very careful** when adding or deleting mesh elements.  New mesh elements must be properly linked to the mesh---for instance, this new vertex must be pointed to one of its associated halfedges by writing something like\r\n\r\n    v->halfedge() = h;\r\n\r\nLikewise, if we delete a mesh element, we must be certain that no existing elements still point to it; the halfedge data structure does not take care of these relationships for you automatically.  In fact, that is exactly the point of this assignment: to get some practice directly manipulating the halfedge data structure.  Being able to perform these low-level manipulations will enable you to write useful and interesting mesh code far beyond the basic operations in this assignment.\r\n\r\nFinally, the **boundary** of the surface (e.g., the ankles and waist of a pair of pants) requires special care in our halfedge implementation.  At first glance, it would seem that the routine `printNeighborPositions()` above might break if the vertex `v` is on the boundary, because at some point we worry that we have no `twin()` element to visit.  Fortunately, our implementation has been designed to avoid this kind of catastrophe.  In particular, rather than having an actual hole in the mesh, we create a \"virtual\" boundary face whose edges are all the edges of the boundary loop.  This way, we can iterate over boundary elements just like any other mesh element.  If we ever need to check whether an element is on the boundary, we have the methods.\r\n\r\n    Vertex::isBoundary()\r\n    Edge::isBoundary()\r\n    Face::isBoundary()\r\n    Halfedge::isBoundary()\r\n\r\nThese methods return true if and only if the element is contained in the domain boundary.  Additionally, we store an explicit list of boundary faces, which we can iterate over like any other type of mesh element:\r\n\r\n   for( FaceCIter b = mesh.boundariesBegin(); b != mesh.boundariesEnd(); b++ )\r\n   {\r\n      // do something interesting with this boundary loop\r\n   }\r\n\r\nThese virtual faces are not stored in the usual face list, i.e., they will not show up when iterating over faces.\r\n\r\nPlease refer to the inline comments (or the Doxygen documentation) for further details.\r\n\r\n#### Task 1 : Edge Flip\r\nIn this task you will implement a local remeshing operation that \"flips\" an edge, by implementing the method `HalfedgeMesh::flipEdge` in <i class=\"icon-file\"> </i>*student_code.cpp*.  In particular, suppose we have a pair of triangles (a,b,c) and (c,b,d).  After flipping the edge (b,c), we should now have triangles (a,d,c) and (a,b,d):\r\n\r\n![Edge flip](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/edgeFlip.png)\r\n\r\nIn more detail, your solution should:\r\n\r\n * Ignore requests to flip boundary edges (just return immediately if either neighboring face is a boundary loop).\r\n * Ignore requests to perform any edge flip that would make the surface non-manifold or otherwise invalidate the mesh.\r\n * Perform only a constant amount of work---the cost of flipping a single edge should **not** be proportional to the size of the mesh!\r\n * Not add or delete any elements.  Since there are the same number of mesh elements before and after the flip, you should only need to reassign pointers.\r\n\r\nFormally proving that your code preserves manifoldness in all cases may be challenging, but at least try to think about what could go wrong in degenerate cases (e.g., vertices of low degree, or very small meshes like a tetrahedron).  The biggest challenge in properly implementing this operation (as well as collapse and split) is making sure that all the pointers still point to the right place in the modified mesh.  An easy recipe for ensuring that all pointers are still valid after a remeshing operation is:\r\n\r\n 1. Draw a picture and/or write down a list of all the elements (vertices, edges, faces, halfedges) that will be needed from the original mesh.\r\n 2. Draw a picture and/or write down a list of all the elements that should appear in the modified mesh.\r\n 3. Allocate any new elements that are needed in the modified mesh, but do not appear in the original mesh.\r\n 4. For every element in the \"modified\" picture, set **all** of its pointers---even if they didn't change.  For instance, for each halfedge, make sure to set `next`, `twin`, `vertex`, `edge`, and `face` to the correct values in the new (modified) picture.  For each vertex, make sure to set its `halfedge` pointer.  Etc.  A convenience method `Halfedge::setNeighbors()` has been created for this purpose.\r\n 5. Deallocate any elements that are no longer used in the modified mesh, which can be done by calling `HalfedgeMesh::deleteVertex()`, `HalfedgeMesh::deleteEdge()`, etc.\r\n \r\nThe reason for setting all the pointers (and not just the ones that changed) is that it is very easy to miss a pointer, causing your code to fail.  Once the code is working, you can remove these unnecessary assignments if you wish---but remember that [premature optimization is the root of all evil](http://c2.com/cgi/wiki?PrematureOptimization)\r\n\r\n\r\n __Possible Extra Credit Extensions:__ \r\n\r\n* Define and implement a \"generalized edge flip\" for faces that are not triangles.  One natural generalization is to move each edge endpoint counter-clockwise around the boundary of the union of the two neighboring faces.\r\n\r\n* Determine the precise conditions under which an edge flip will preserve manifoldness, and write a formal proof showing that these conditions are indeed necessary and sufficient.\r\n \r\n#### Task 2: Edge Split\r\n\r\nIn this task you will make a different local modification to the mesh in the neighborhood of an edge, called a __split__.  In particular, suppose we have a pair of triangles (a,b,c) and (c,b,d).  The edge (b,c) is split by inserting a new vertex m at its midpoint and connecting it to the opposite vertices a and d, yielding four triangles:\r\n\r\n![Edge split](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/edgeSplit.png)\r\n\r\nUnlike the previous operation (flip), you will have two allocate new mesh elements this time (e.g., two new triangles, two edges, some halfedges...).  Your implementation should:\r\n\r\n * Ignore requests to split boundary edges (just return immediately if either neighboring face is a boundary loop).\r\n * Assign the position of the new vertex to the midpoint of the original edge, i.e., the average of its two endpoints (see `Vertex::position`).\r\n * Perform only a constant amount of work---the cost of splitting a single edge should **not** be proportional to the size of the mesh!\r\n * Allocate only as many new elements as needed; there should be no \"orphaned\" elements that are not connected to the rest of the mesh.\r\n * Preserve the manifoldness and validity of the mesh.\r\n\r\nThis time around, preserving manifoldness is straightforward since an edge split doesn't change the topology of the underlying surface (however, you should still be careful to point all your pointers at the right elements!).  To obtain a correct implementation, you might try following the same \"recipe\" given in the previous task (though clever, clean, and simple alternatives are of course always welcome).  To verify that your implementation works correctly, try flipping some edges that you've split, and splitting some edges that you flipped.\r\n\r\n__Possible extra credit extensions:__\r\n\r\n* Split boundary edges by splitting the interior face and adding a single vertex to the boundary face (see `Face::isBoundary()`).\r\n\r\n* Implement edge split for general polygons, rather than just triangles.\r\n\r\n* Implement __vertex split__, which is essentially the inverse of the edge collapse you'll implement in the next task.\r\n\r\n#### Task 3: Edge Collapse\r\n\r\nThe third and final operation you will implement is an __edge collapse__, which contracts an edge to a single point.  In particular, suppose we have a pair of triangles (a,b,c) and (c,b,d).  The edge (b,c) is collapsed by replacing both vertices b and c with a single vertex m, and replacing triangles (a,b,c) and (c,b,d) with edges (a,m) and (m,d), respectively:\r\n\r\n![Edge collapse](http://15462.courses.cs.cmu.edu/fall2015content/misc/asst2_images/edgeCollapse.png)\r\n\r\nThis time around you will need to __delete__ mesh elements, rather than allocate new ones.  Deleting elements is especially tricky, because references to these elements may be needed in order to construct the modified mesh---the simplest thing is to simply wait until the end of the edge collapse routine to actually call `deleteVertex()`, `deleteEdge()`, etc.  Your implementation should:\r\n\r\n * Ignore requests to collapse boundary edges (just return immediately if either neighboring face is a boundary loop).\r\n * Assign the position of the collapsed vertex to the midpoint of the original edge.\r\n * Perform only a constant amount of work---the cost of collapsing a single edge should **not** be proportional to the size of the mesh!\r\n * Preserve the manifoldness and validity of the mesh.\r\n\r\nJust like edge flips, there may be situations where an edge cannot be collapsed without violating the manifold property of the mesh; once again, you should think carefully about when an edge can and cannot be safely collapsed.  (For instance, what happens if you collapse an edge of a tetrahedron?  Do you still have a valid mesh?  What if you collapse one more edge after that?)\r\n\r\n__Possible Extra Credit Extensions:__\r\n\r\n* Implement edge collapse for general polygonal meshes (instead of just triangles).\r\n\r\n* Determine the precise conditions under which an edge collapse will preserve manifoldness, and write a formal proof showing that these conditions are indeed necessary and sufficient.\r\n\r\n * Collapse boundary edges by collapsing the interior triangle and removing the collapsed edge from the boundary loop.\r\n\r\n#### Going Further: Tasks that May Potentially Win You Extra Credit:\r\n\r\n##### Implement More Advanced Modeling Tools #####\r\n\r\nMany popular modeling tools are based on the same kinds of local remeshing operations you've been implementing for this assignment.  For instance, a very common operation is to \"bevel\" or \"fillet\" an edge, to make sharp corners round.  Alternatively, faces can be extruded to add more detail to an existing surface.  Our basic editor could be turned into a more full-fledged modeling tool by implementing common operations found in packages like __Maya__ or __Blender__---or inventing your own!  (An additional challenge here is that you may have to add some additional functionality to the GUI (graphical user interface), by modifying methods in `MeshEditor.cpp`, in order to give users an interface to your new editing tools.)\r\n\r\n#### Tasks 4, 5, & 6: Global Surface Upsampling, Downsampling, and Resampling\r\n\r\nThe three local remeshing operations __split__, __collapse__, and __flip__ are effectively small steps toward upsampling, downsampling, and resampling the surface.  In the second half of the assignment, you will combine these operations in various ways to perform a global remeshing of the surface.  Stay tuned for more information!\r\n\r\n### Grading\r\n\r\nYour code must run on the GHC 5xxxx cluster machines as we will grade on those machines. Do not wait until the submission deadline to test your code on the cluster machines. Keep in mind that there is no perfect way to run on arbitrary platforms. If you experience trouble building on your computer, while the staff may be able to help, but the GHC 5xxx machines will always work and we recommend you work on them.\r\n\r\nEach task will be graded on the basis of correctness.  You are not expected to completely reproduce the reference solution vertex-for-vertex as slight differences in implementation strategy or even the order of floating point arithmetic will causes differences, but your solution should not be very far off from the provided input/output pairs.  If you have any questions about whether your implementation is \"sufficiently correct\", just ask.\r\n\r\nThe assignment consists of a total of 100 pts. The point breakdown is as follows:\r\n\r\n* Task 1:  15\r\n* Task 2:  15 \r\n* Task 3:  15\r\n* Task 4:  18\r\n* Task 5:  18\r\n* Task 6:  19\r\n\r\n### Handin Instructions\r\n\r\nTBD\r\n\r\n\r\n### Friendly Advice from your TAs\r\n* As always, start early.  There is a lot to implement in this assignment, and no official checkpoint, so don't fall behind!\r\n \r\n* Be careful with memory allocation, as too many or too frequent heap allocations will severely degrade performance.\r\n\r\n* Make sure you have a submission directory that you can write to as soon as possible. Notify course staff if this is not the case.\r\n\r\n* While C has many pitfalls, C++ introduces even more wonderful ways to shoot yourself in the foot. It is generally wise to stay away from as many features as possible, and make sure you fully understand the features you do use.\r\n\r\n### Resources and Notes\r\n* [The Half-Edge Data Structure](http://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml) - another tutorial on the halfedge data structure.\r\n\r\n* [OpenMesh](https://www.graphics.rwth-aachen.de/media/papers/openmesh1.pdf) - a different implementation than the one used in our assignment, but discusses some of the software design challenges associated with building a halfedge data structure.\r\n\r\n* [Bryce's C++ Programming Guide](https://github.com/Bryce-Summers/Writings/blob/master/Programming%20Guides/C_plus_plus_guide.pdf)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}